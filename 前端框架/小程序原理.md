## 小程序渲染原理

小程序渲染原理：双线程架构，本质是使用webview进行渲染，一个JS线程负责处理逻辑，另一个JS线程负责渲染，这样一方面可以实现沙箱，对不安全的浏览器API操作进行屏蔽，另一方面也可以让渲染和逻辑操作同步，优化速度

逻辑层和渲染层依赖Native层的JS桥进行通信，由于桥只能传递基本数据类型，因此每次setData本质上是要对传递的对象进行序列化操作

## 小程序的优化手段
* 减少setData次数和大小（每次setData都会序列化）
* 仅将渲染相关的数据写在data中
* 预处理数据，减少数据中的大小，可以配合渲染层实现一些协议，比如有一个很大的字符串，可以将这个字符串写在渲染层（wxml中），当然为了可维护性，也可以在编译时加入，然后在对象中用特定key值表示这个值，来减少setData的大小，rgba颜色也可以这样处理
* 分片渲染，分组渲染，虚拟列表等，注意小程序中虚拟列表要考虑仔细，因为小程序更新视图数据也是消耗性能较大的工作。如果虚拟列表中的数据结构比较复杂，可能减少Dom操作的优化小于多次更新数据的序列化性能消耗导致负优化
* 注意更新顺序和数据同步问题，由于小程序是页面栈架构的，在使用状态管理时，可能出现一个页面数据更新，另一个没有展示的页面也会进行视图更新，导致性能问题。这一点需要封装页面级的状态调度工具来解决
* 尽量不使用视图层逻辑来更新状态，可以使用订阅发布或状态管理代替
* 分包

## 分包
小程序支持分包，预加载

一般而言不同子包无法通信，但小程序提供了异步加载的方式，当一个子包调用另一个子包时，可以通过异步加载的方式来等到另一个子包加载完成时调用

小程序支持独立分包，独立分包可以不依赖于主包的加载

## 多端框架原理
不论是小程序还是类似tora这样的多端框架，基本原理都是运行时+编译时

编译时负责将源代码编译成渲染层的样子，比如小程序就是将wxml编译为渲染层的render函数，taro就是将react编译为wxml或swan等小程序视图层，这部分一般是在打包时完成的

运行时是代码在运行时，会注入一些运行时代码，来完成对应平台的功能和自己特定的API，比如小程序的运行时会在window上注入wx，getAPP等对象。taro在运行时则会根据打包的平台进行注入