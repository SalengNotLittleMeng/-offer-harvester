## 小程序渲染原理

小程序渲染原理：双线程架构，本质是使用webview进行渲染，一个JS线程负责处理逻辑，另一个JS线程负责渲染，这样一方面可以实现沙箱，对不安全的浏览器API操作进行屏蔽，另一方面也可以让渲染和逻辑操作同步，优化速度

逻辑层和渲染层依赖Native层的JS桥进行通信，由于桥只能传递基本数据类型，因此每次setData本质上是要对传递的对象进行序列化操作

## 小程序的优化手段
减少setData次数和大小，注意小程序内部会做合并处理，所以减少连续的两个setData并不会优化，需要将多个事件队列中的setData合并才能优化。同时，taro这些跨端框架会执行setData的diff操作，对比出前后变化差异最小化更新，因此也不需要特殊处理。原生小程序可以选择重写setData方法，增加一层diff

仅将渲染相关的数据写在data中,其他数据可以写在实例上

预处理数据，减少数据中的大小，可以配合渲染层实现一些协议，比如有一个很大的字符串，可以将这个字符串写在渲染层（wxml中），然后在对象中用特定key值表示这个值，来减少setData的大小。比如rgba颜色也可以这样处理，逻辑层传入red，渲染层使用rgba(255, 0, 0, 1)。渲染层预处理的代码可以写在wxml中的wxs标签中

分片渲染，分组渲染，虚拟列表等，注意小程序中虚拟列表要考虑仔细，因为小程序更新视图数据也是消耗性能较大的工作。如果虚拟列表中的数据结构比较复杂，可能减少Dom操作的优化小于多次更新数据的序列化性能消耗导致负优化

注意更新顺序和数据同步问题，由于小程序是页面栈架构的，在使用状态管理时，可能出现一个页面数据更新，另一个没有展示的页面也会进行视图更新，导致性能问题。这一点需要封装页面级的状态调度工具来解决，比如页面A数据更新，使用状态管理工具关联了A页面中数据的页面B不应该立刻触发更新，而是把这个操作延迟，等到B页面加载时再更新

状态提升，将子组件状态提升到父组件来减少数据更新频率

尽量不使用视图层逻辑来更新状态，可以使用订阅发布或状态管理代替

 分包，分包小程序支持分包，预加载。一般而言不同子包无法通信，但小程序提供了异步加载的方式，当一个子包调用另一个子包时，可以通过异步加载的方式来等到另一个子包加载完成时调用。另外，小程序支持独立分包，独立分包可以不依赖于主包的加载

请求前置，比如将路由后的初始化请求前置到路由前，或者将onLoad的请求前置到onLaunch

预加载，小程序提供预加载配置，具体如何预加载可能需要埋点调研或推测

通用优化手段：懒加载，CDN，图片格式降级，缓存等通用手段

## 分包
小程序支持分包，预加载

一般而言不同子包无法通信，但小程序提供了异步加载的方式，当一个子包调用另一个子包时，可以通过异步加载的方式来等到另一个子包加载完成时调用

小程序支持独立分包，独立分包可以不依赖于主包的加载

## 多端框架原理
不论是小程序还是类似tora这样的多端框架，基本原理都是运行时+编译时

编译时负责将源代码编译成渲染层的样子，比如小程序就是将wxml编译为渲染层的render函数，taro就是将react编译为wxml或swan等小程序视图层，这部分一般是在打包时完成的

运行时是代码在运行时，会注入一些运行时代码，来完成对应平台的功能和自己特定的API，比如小程序的运行时会在window上注入wx，getAPP等对象。taro在运行时则会根据打包的平台进行注入