1.prefetch预加载
2.请求前置
3.每次setData都需要经过Native bridge，会将数据显转化为base64，在转化为对象（序列化），因此尽量将多个setData合并，并减少对应的值的内存大小
4.ws会导致每次数据更新都对整个协议要进行data_>base64->data的序列化过程，可以对QPS进行检测（<150），丢弃不重要的协议，减少序列化过程
5.跟端能力相关的操作尽可能做缓存（涉及数据序列化）
6.request方法可以配置参数defer：true，将请求在渲染闲置时进行调用
7.骨架屏，官方提供了对应策略和接口
8.资源上云，减少包大小
9.分包
10。请求最好不要用promise包裹，最好并行请求

高流量页面将请求放在 onInit 生命周期

首屏优化，第一次渲染近渲染首屏数据，之后再渲染后续内容，内容较少时需要考虑强行触发fmp

打点优化：监听FPM事件，在FPM后且日志达到一定数量后打点
eventBus.app.firstMeaningfulPainted.on(() => {
	canIReport = true;
});

内存优化：
使用cheap-module-source-map

通过打包脚本修改，仅保留必要source-map
错误捕获：
// 可捕获项目中大部分错误
    Vue.config.errorHandler
        // 捕获未catch的promise错误
    window.addEventListener('unhandledrejection', event => {})
        // 可监听到非promise的异步错误
    window.addEventListener('error', function (event = {}) {})

    小程序团队目前做的优化：

    1.用rust代替node来实现loader
    2.使用了cssnano处理优化css,对功能进行裁剪
    3.分析主包和子包包含的自定义组件，做筛选
    4.编译优化，将AST操作前置到loader阶段并缓存，不会重复生成ast，JS->ast-css:js-字符匹配-css
    5.createChunkAssets筛选，小程序编译通过addEntry将每个组件打入webpack工作流，导致出现过多chunk,造成过多不必要的计算，因此应该对chunk进行筛选