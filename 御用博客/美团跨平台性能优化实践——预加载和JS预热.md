# 美团跨平台性能优化实践——容器化预加载和JS预热

## Picasso简介

性能优化在开发领域是一个经久不衰的话题，同时，移动端app作为用户量最庞大的设备，秒开率，Tp等性能指标更是尤为重要，但必须注意的是，移动端的内容也是更常变更的部分，传统Native开发的一大弊端就是，定式的开发方式无法满足不断变化的需求。

因此，混合app正在逐渐代替Native开发成为主流，社区也有包括flutter,react-native，uniapp等成熟的手段。而在美团系的移动端产品中，采用的则是美团内部自研的跨端框架Picasso，可以一套化的开发去适配小程序，H5，安卓，IOS等平台。

相比于Native方案，Picasso实现了容器隔离，可以对js-bundle进行动态引入，大大降低了模块之间耦合程度和版本更新的成本，使开发环境不必与部署环境强耦合，只要使用模拟器编写JavaScript，就可以使用框架转译为bundle并引入，而不必像RN那样将开发环境与虚拟机/真机进行强绑定，即使在浏览器的环境下也可以进行跨端开发，大大提高了开发体验。

同时，相对于RN，flutter等方案，Picasso实现了完全的容器化，在既定的容器里，将JS代码编译成P-model，然后根据各平台的差异提供接口进行转译，利用中间产物屏蔽了各个平台的底层差异，不必像RN那样使用JS-bridge去手动写一部分Native代码来屏蔽平台差异，拥有更好的兼容性和适配性

Picasso目前的整体秒开率已经达到90%以上，但对于框架来说，优化永远是一个不间断的过程，目前Picasso团队正在为将Picasso项目的整体秒开率提高到99%而努力，而其中一个比较好的切入点就是基于容器化的预加载和JS预热

## 预加载

所谓预加载，就是将一部分将要执行的代码提前进行请求并缓存到本地，当使用这些数据的时候就可以基于Picasso缓存优先的准则优先调用缓存，这样就可以将进入页面后加载数据的过程前移，达到加快页面开启速度的效果

但是这样就会有一个问题，那就是我们应该在什么时候去执行预加载的操作，显然，如果我们在不合适的时机（比如当前页面进行大量计算或绘制时）进行预加载的操作，那么必然会影响当前页面的性能状况。而我们预期的是**在不影响当前页面性别的情况下，优化后续页面的进入速度**，那么，如何确定在何时，如何进行预加载就变得异常重要，确切来说，如何执行预加载跟三个因素有关：

* 资源：去加载哪些资源，加载多少资源
* 事件：在什么时机去进行预加载的操作
* 优先级：如果一个页面之后可能路由到多个页面，那么这些页面进行预加载的优先级和顺序该如何确定？

那么，我们该如何把握这些因素呢？

### 资源和优先级：基于统计的路由权重图

首先，我们可以通过埋点上报的数据进行分析，去分析出当用户各个页面后，接下来跳转到其他各个页面的可能性，最后得出一个有向图的数据结构。当用户在某一个页面时，就可以利用这个有向图去分析出加载各个资源的优先级和权重，同时，我们还可以使用埋点和端智能，对这些权重进行进一步细化，去加大预测的命中率

### 事件：基于埋点SDK的hook去选择加载时机

一般来说，我们应该将业务代码和处理预加载的代码进行解耦，也就以为着我们不可能在各个页面中手动去收集触发预加载的hook。 我们可以通过埋点SDK来获取用户操作app的整个行为链，再次的基础上去开发可以接入埋点系统的SDK，在这个SDK中添加多个hook，这些hook会获取埋点系统收集的用户操作和代码运行数据，并在我们认为触发预加载的合适时机进行触发，而我们只需要在业务代码中订阅这些hook触发预加载即可，用这种方式来达到业务代码和预加载优化的解耦

利用埋点构建页面加载顺序图

路径访问建模和推断

JS预热：提前将JS加载到容器中，使用双引擎同时加载，通过host缓存池，在相应的页面中对对应可能加载的js进行预热



优化手段：内置js,预下载，预热

请求合并和请求前置

预下载和内置js缓存策略：当请求列表到达一定长度后，利用版本号对比后台数据更新

一定时间后当用户进入后台进行更新

内置js：在繁忙状态（从外链进入页面）下的JS或出现问题后后备方案，弱网时的效果等，内置js可以在特定的时间进行请求删除覆盖


容器准备阶段：Picasso准备业务JS环境的过程，容器准备完成后才能真正开始执行Picasso的业务逻辑

容器初始化：Native容器ViewController/Activity初始化的过程

获取JS：获取业务JS资源的过程，优先取本地缓存，无缓存时通过网络拉取

加载JS：将业务JS加载到JS引擎中，完成JS侧页面实例的创建。Picasso是采用单引擎机制，所有的业务运行在同一个JS引擎中，仅App启动后第一个使用Picasso的业务需要创建引擎，后面打开的业务都是复用同一个引擎。

获取业务数据：获取页面加载所需要的业务数据的过程

请求参数准备：发起业务请求通常需要准备一系列参数，如用户信息，定位等，这类信息通常需要通过桥来获取。该阶段耗时通常意味着业务使用的某些桥的耗时。

请求数据：真正发起请求至JS侧获取到数据的过程，包括了网络请求和数据反序列化

首屏渲染：执行业务JS逻辑，直至完成首屏渲染的过程

预计算：执行JS布局逻辑得到结构化的视图数据，并将JS侧的结构化的视图数据转换为Native结构化的视图数据的过程

视图绘制：根据Native结构化的视图数据创建并绘制Native视图

其他方法：使用单线程优化数据桥的使用

取消不必要的数据序列话和反序列化

减少首屏渲染的数据，预计算，根据业务预测出渲染首屏幕需要的数据量（滚动组件）

引擎：mtnn:基于阿里的mnn

交互层：展示卡片，动态添加替换，执行浮层

策略层（云）：意图推导，调用服务返回数据

触发层：规则，脚本，模型识别，触发对应钩子（alita端智能）

数据层：埋点上报收集信息，停留，滑动，移动等

基于规则引擎（sdk）——》相对于策略脚本和native开发可进行可视化配置（设置规则dsl）

规则引擎：
    * 感知用户行为：单个埋点
    * 感知用户意图：多个埋点以及顺序（描绘用户画像）
    * 识别结果，通过客户端或网络请求进行触达用户

相比于云智能，仅需要拉去少部分客户端数据和更新规则信息，可以利用差异缓存（用版本号进行判断）进行差异更新

多平台联动时进行配置校验并对接大象

规则引擎sdk：通过埋点方案获取行为，通过桥（本地）缓存的数据和请求到的规则不断进行匹配，匹配到对应行为则触发对应的钩子

交互式推荐和问卷调查

智能触达和商家防打扰

埋点，获取成功率，匹配成率，异常上报

端智能的优势：快速，不必上传云端，数据利用率高，用户信息安全，个性化定制

应用：智能推荐，触达矩阵，动态话列表，信息重排，智能推荐，预加载，智能运营（红包，折扣，挽留用户）,美颜，图像识别

端智能会将特征（埋点SQL），算子（数据计算的能力），模型（提前训练好的离线数据模型）下发到端

后台下发服务端数据，模型 参数（特征权重等）即可

列表首次渲染-初始化sdk——用户交互收集-——端智能推理--利用桥进行数据传输——卡控（保证渲染过的不会被排序）——修改后续列表

通过桥对数据进行对接