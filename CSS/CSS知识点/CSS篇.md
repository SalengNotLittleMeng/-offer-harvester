# CSS篇

## CSS优先级

浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。

### 关于选择器优先级要注意的点：

* 1.!important的优先级是最高的。（没有这个属性的话，则按照下面的向量来计算优先级）
* 2.**行内样式：id选择器数量：类选择器，属性选择器，伪类选择器：类型和伪元素选择器：通配符，子类元素选择器，兄弟元素选择器的数量=1000：100：10：1：0**
* 3.权重相同，看谁的定义靠后，越靠后就会覆盖掉前面的样式
* 4.通配符、子选择器、兄弟选择器，虽然权重为0000，但是优先于继承的样式
* 5.以上数值化的权重值只是我们拟化的，不代表着多个低等级的选择器就能超过1个高等级的选择器。无论多少个低等级的选择器都不会超过一个高等级选择器的优先度,更确切地说，1000,100,10,1不是十进制中的1000,100,10,1，而是进制数，不是2进制，不是10进制，而是256进制，就是0到255后+1才是1，比如通配符的权重为0，伪元素的权重为1，中间相差了255，依次类推。
* 6.！important代表无穷大，但在计算机中，无穷大是一个有限的概念，！important<!important+1
* 7.[:not]否定伪类在优先级计算中会忽略掉:not，按照:not里面的选择器进行计算优先度。其他伪类(如:hover)参与CSS优先级的计算，但是[:not]不参与计算。
* 8.优先级计算无视DOM树中的距离
* 9.如果权重相同，那么内联样式>嵌入样式表>外联样式
* 10.宽高会被max-width/min-width覆盖，所以!important会失效。

##@规则
通常样式表会包括大量的规则列表。但有时候也需要在样式表中包括其他的一些信息，比如字符集，导入其它的外部样式表，字体等，这些需要专门的语句表示。

* @namespace 告诉 CSS 引擎必须考虑XML命名空间。
* @media, 如果满足媒体查询的条件则条件规则组里的规则生效。
* @page, 描述打印文档时布局的变化.
* @font-face, 描述将下载的外部的字体。
* @keyframes, 描述 CSS 动画的关键帧。
* @document, 如果文档样式表满足给定条件则条件规则组里的规则生效。 (推延至 CSS Level 4 规范)
* @charset 用于定义样式表使用的字符集。它必须是样式表中的第一个元素。如果有多个 @charset 被声明，只有第一个会被使用，而且不能在HTML元素或HTML页面的style元素内使用。
* @supports 用于查询特定的 CSS 是否生效，可以结合 not、and 和 or 操作符进行后续的操作
* @import 用于告诉 CSS 引擎引入一个外部样式表。
### link 和 @import 都能导入一个样式文件，它们有什么区别嘛？

* link 是 HTML 标签，除了能导入 CSS 外，还能导入别的资源，比如图片、脚本和字体等；而 @import 是 CSS 的语法，只能用来导入 CSS；
* link 导入的样式会在页面加载时同时加载，@import 导入的样式需等页面加载完成后再加载；
* link 没有兼容性问题，@import 不兼容 ie5 以下；
* link 可以通过 JS 操作 DOM 动态引入样式表改变样式（写在docment内），而@import不可以。
* @import引入的CSS默认写在CSS文件的头部，可能会产生层级覆盖问题

## CSS的层叠性
CSS 中的核心特性之一，用于合并来自多个源的属性值的算法。当一个元素被多个源修改了属性，那么最终决定采用那个属性就取决于层叠性

## 继承性

CSS的继承性是伪类简化我们的CSS代码，子元素会继承父元素对应属性计算后的值

可以被继承的属性：

* 字体相关：font-family、font-style、font-size、font-weight 等；
* 文本相关：text-align、text-indent、text-decoration、text-shadow、letter-spacing、word-spacing、 white-space、line-height、color 等；
* 列表相关：list-style、list-style-image、list-style-type、list-style-position 等；
* 其他属性：visibility、cursor 等；

CSS中特殊的属性值：

* inherit：继承父元素对应属性的计算值；
* initial：应用该属性的默认值，比如 color 的默认值是 #000；
* unset：如果属性是默认可以继承的，则取 inherit 的效果，否则同 initial；
* revert：效果等同于 unset，兼容性差。

## 文档流
* 块级元素默认会占满整行，所以多个块级盒子之间是从上到下排列的；
* 内联元素默认会在一行里一列一列的排布，当一行放不下的时候，会自动切换到下一行继续按照列排布；

### 脱离文档流

脱离文档流后，元素不占据父容器的空间，不影响父元素中其他元素的布局，计算父容器高度时不会将其纳入。
脱离文档流的方法：
* 浮动，浮动元素之前所占据的区域会由其他元素填充，浮动之后所占据的区域不会跟其他元素重叠。
* 使用绝对定位或fix定位，脱离文档流以后的位置会让其他元素自动填补。

## 盒模型
*  CSS 中任何元素都可以看成是一个盒子，而一个盒子是由 4 部分组成的：内容（content）、内边距（padding）、边框（border）和外边距（margin）。
*  内容（设置的宽/高） + 内边距 + 边框
*  IE 盒模型认为：盒子的实际尺寸 = 设置的宽/高 = 内容 + 内边距 + 边框

当给一个盒子设置一个display属性时，会决定盒子的两个display type：

* outer display type（对外显示）：决定了该元素本身是如何布局的，即参与何种格式化上下文；
* inner display type（对内显示）：其实就相当于把该元素当成了容器，规定了其内部子元素是如何布局的，参与何种格式化上下文；

* 对外显示方面，盒子类型可以分成 2 类：block-level box（块级盒子） 和 inline-level box（行内级盒子）。
* 对内方面，其实就是把元素当成了容器，里面包裹着文本或者其他子元素。container box 的类型依据 display 的值不同，分为 4 种：

block container：建立 BFC 或者 IFC；
flex container：建立 FFC；
grid container：建立 GFC;
ruby container

如果把 img 这种替换元素（replaced element）申明为 block 是不会产生 container box 的

## 格式化上下文
格式化上下文（Formatting Context）规定了渲染区域内部的子元素是如何排版以及相互作用的。

不同类型的盒子有不同格式化上下文，大概有这 4 类：

* BFC (Block Formatting Context) 块级格式化上下文；
* IFC (Inline Formatting Context) 行内格式化上下文；
* FFC (Flex Formatting Context) 弹性格式化上下文；
* GFC (Grid Formatting Context) 格栅格式化上下文；

### BFC
块级格式化上下文，它是一个独立的渲染区域，只有块级盒子参与，它规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。
#### BFC渲染规则
* 内部的盒子会在垂直方向，一个接一个地放置；
* 盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；
* 每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；
* BFC 的区域不会与 float 盒子重叠；
* BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
* 计算 BFC 的高度时，浮动元素也参与计算。

#### 创建BFC的方法
* 根元素：html
* 非溢出的可见元素：overflow 不为 visible
* 设置浮动：float 属性不为 none
* 设置定位：position 为 absolute 或 fixed
* 定义成块级的非块级元素：display: inline-block/table-cell/table-caption/flex/inline-flex/grid/inline-grid
### BFC的应用
* 1、 自适应两栏布局
* 2、清除内部浮动（解决浮动造成的高度坍塌）
* 3、防止垂直 margin 合并（给其中一个元素的包裹层触发BFC）

### IFC
块级元素中仅包含内联级别元素时，就会触发IFC

#### IFC 渲染规则

* 子元素在水平方向上一个接一个排列，在垂直方向上将以容器顶部开始向下排列；
* 节点无法声明宽高，其中 margin 和 padding 在水平方向有效在垂直方向无效；
* 节点在垂直方向上以不同形式对齐；
* 能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的线盒（line box）。线盒的宽度是由包含块（containing box）和与其中的浮动来决定；
* IFC 中的 line box 一般左右边贴紧其包含块，但 float 元素会优先排列。(图片排版)
* IFC 中的 line box 高度由 line-height 计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同；
* 当内联级盒子的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性值来决定；
* 当一个内联盒子超过父元素的宽度时，它会被分割成多盒子，这些盒子分布在多个 line box 中。如果子元素未设置强制换行的情况下，inline box 将不可被分割，将会溢出父元素。

## 层叠上下文

* z-index 能够在层叠上下文中对元素的堆叠顺序其作用是必须配合定位才可以；
* 除了 z-index 之外，一个元素在 Z 轴上的显示顺序还受层叠等级和层叠顺序影响；
 
**符合以下任一条件的元素都会产生层叠上下文**

* html 文档根元素
* 声明 position: absolute/relative 且 z-index 值不为 auto 的元素；
* 声明 position: fixed/sticky 的元素；
* flex 容器的子元素，且 z-index 值不为 auto；
* grid 容器的子元素，且 z-index 值不为 auto；
* opacity 属性值小于 1 的元素；
* mix-blend-mode 属性值不为 normal 的元素；
* 以下任意属性值不为 none 的元素：

transform
filter
perspective
clip-path
mask / mask-image / mask-border


* isolation 属性值为 isolate 的元素；
* -webkit-overflow-scrolling 属性值为 touch 的元素；
* will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；
* contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。

#### 层叠等级

层叠等级指节点在三维空间 Z 轴上的上下顺序。它分两种情况：

* 在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在 Z 轴上的上下顺序；
* 在其他普通元素中，它描述定义的是这些普通元素在 Z 轴上的上下顺序；

普通节点的层叠等级优先由其所在的层叠上下文决定，层叠等级的比较只有在当前层叠上下文中才有意义，脱离当前层叠上下文的比较就变得无意义了。

### 层叠顺序

以下这个列表越往下层叠优先级越高：

* 层叠上下文的 border 和 background
* z-index < 0 的子节点
* 标准流内块级非定位的子节点
* 浮动非定位的子节点
* 标准流内行内非定位的子节点
* z-index: auto/0 的子节点
* z-index > 0的子节点

#### 如何比较两个元素的层叠等级？

* 在同一个层叠上下文中，比较两个元素就是按照层叠顺序进行比较。
* 如果不在同一个层叠上下文中的时候，那就需要比较两个元素分别所处的层叠上下文的等级。
* 如果两个元素都在同一个层叠上下文，且层叠顺序相同，则在 HTML 中定义越后面的层叠等级越高。

## 值和单位

值的类型：

* 数值
* 百分比
* 坐标位置
* 函数

CSS的单位：

* px：表示一个像素点，浏览器做基础的单位。具体渲染也跟设备像素比有关，实际转换时，CSS像素会根据设备像素转换为物理像素。分辨率：屏幕横纵方向上的像素点的数量
* em:em是一个相对长度，具体含义有两层意思：
	1. 在font-size中使用，表示相对于**父元素**的字体大小
	2. 在其他属性中使用，表示相对于**自身字体大小**


em计算时会一层一层地叠加计算

* rem也是一个相对长度单位，但他相对的是html的字体大小
* vw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位

CSS中颜色的表示方式包括：

* 颜色关键字
* RGBA(red,green,blue,alpha)
* 十六进制（值越大颜色越深）
* 函数符
* HSLA（色相，饱和度，亮度，不透明度）

在控制台中按住shift+鼠标左键可以切换颜色的表示方式

transparent关键字：它是带有 alpha 通道为最小值的黑色，是 rgba(0,0,0,0) 的简写

应用场景：

* 画三角
* 增大点击区域

currentColor 关键字：取当前元素继承父级元素的文本颜色值或声明的文本颜色值

## 媒体查询
媒体查询是指针对不同的设备、特定的设备特征或者参数进行定制化的修改网站的样式。

可以通过给 <link> 加上 media 属性来指定该样式文件只能对什么设备生效，不指定的话默认是 all，即对所有设备都生效： 还可以通过 @media 让 CSS 规则在特定的条件下才能生效

## 动画与过渡

几个易混淆的概念：

* animation（动画）
用于设置动画属性，他是一个简写的属性，包含6个属性


* transition（过渡）
用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同


* transform（变形）
用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表”


* translate（移动）
translate只是transform的一个属性值，即移动。

## CSS单位

px：像素，固定大小单位
em：相对于当前元素字体大小的单位
rem：相对于根元素（HTML）字体大小的单位
%：相对于父元素的百分比单位
vh：相对于视口高度的 1/100 单位
vw：相对于视口宽度的 1/100 单位
cm：厘米，实际尺寸单位
mm：毫米，实际尺寸单位
in：英寸，实际尺寸单位
pt：磅，字体尺寸单位
pc：pica，字体尺寸单位
svw：移动端当输入栏最大时的vw
lvw:移动端当输入栏最小时的vw
dvw：移动端实际页面尺寸自适应vw
